use std::io::Read;

pub enum OpParseError {
    UnexpectedEOF,
    InvalidByteCode,
}

#[repr(u8)]
pub enum Op {
    AALoad,
    AAStore,
    AConstNull,
    ALoad(u8),
    ANewArray(u16),
    AReturn,
    ArrayLength,
    AStore(u8),
    AThrow,
    BALoad,
    BAStore,
    BIPush(i8),
    CALoad,
    CAStore,
    CheckCast(u16),
    D2F,
    D2I,
    D2L,
    DAdd,
    DALoad,
    DAStore,
    DCmpG,
    DCmpL,
    DConst0,
    DConst1,
    DDiv,
    DLoad(u8),
    DLoad0,
    DLoad1,
    DLoad2,
    DLoad3,
    DMul,
    DNeg,
    DRem,
    DReturn,
    DStore(u8),
    DSub,
    Dup,
    DupX1,
    DupX2,
    Dup2,
    Dup2X1,
    Dup2X2,
    F2D,
    F2I,
    F2L,
    FAdd,
    FALoad,
    FAStore,
    FCmpG,
    FCmpL,
    FConst0,
    FConst1,
    FConst2,
    FDiv,
    FLoad(u8),
    FMul,
    FNeg,
    FRem,
    FReturn,
    FStore(u8),
    FSub,
    GetField(u16),
    GetStatic(u16),
    Goto(u16),
    GotoW(u32),
    I2B,
    I2C,
    I2D,
    I2F,
    I2L,
    I2S,
    IAdd,
    IALoad,
    IAnd,
    IAStore,
    IConstM1,
    IConst0,
    IConst1,
    IConst2,
    IConst3,
    IConst4,
    IConst5,
    IDiv,
    IfACmpEq(u16),
    IfACmpNe(u16),
    IfICmpEq(u16),
    IfICmpNe(u16),
    IfICmpLt(u16),
    IfICmpGe(u16),
    IfICmpGt(u16),
    IfICmpLe(u16),
    IfEq(u16),
    IfNe(u16),
    IfLt(u16),
    IfGe(u16),
    IfGt(u16),
    IfLe(u16),
    IfNonNull(u16),
    IfNull(u16),
    IInc(u8, i8),
    ILoad(u8),
    IMul,
    INeg,
    InstanceOf(u16),
    InvokeDynamic(u16),
    InvokeInterface(u16, u8),
    InvokeSpecial(u16),
    InvokeStatic(u16),
    InvokeVirtual(u16),
    IOr,
    IRem,
    IReturn,
    IShl,
    IShr,
    IStore(u8),
    ISub,
    IUShr,
    IXor,
    Jsr(u16),
    JsrW(u32),
    L2D,
    L2F,
    L2I,
    LAdd,
    LALoad,
    LAnd,
    LAStore,
    LCmp,
    LConst0,
    LConst1,
    LDC(u8),
    LDCW(u16),
    LDC2W(u16),
    LDiv,
    LLoad(u8),
    LMul,
    LNeg,
    LookupSwitch {
        default: u32,
        npairs: Vec<(i32, i32)>,
    },
    LOr,
    LRem,
    LReturn,
    LShl,
    LShr,
    LStore(u8),
    LSub,
    LUShr,
    LXor,
    MonitorEnter,
    MonitorExit,
    MultiANewArray(u16, u8),
    New(u16),
    NewArray(AType),
    Nop,
    Pop,
    Pop2,
    PutField(u16),
    PutStatic(u16),
    Ret(u8),
    Return,
    SALoad,
    SAStore,
    SIPush(u16),
    Swap,
    TableSwitch {
        default: i32,
        low: i32,
        high: i32,
        offsets: Vec<i32>,
    },
    Wide,
    Breakpoint,
}

#[repr(u8)]
pub enum AType {
    TBoolean = 4,
    TChar = 5,
    TFloat = 6,
    TDouble = 7,
    TByte = 8,
    TShort = 9,
    TInt = 10,
    TLong = 11,
}

macro_rules! read_bytes {
    ($source:expr, $count:expr) => {{
        let mut buf = [0_u8; $count];
        $source
            .read_exact(&mut buf)
            .or(Err(OpParseError::UnexpectedEOF))?;
        buf
    }};
}

macro_rules! read_u8 {
    ($source:expr) => {{
        u8::from_be_bytes(read_bytes!($source, 1))
    }};
}

macro_rules! read_i8 {
    ($source:expr) => {{
        i8::from_be_bytes(read_bytes!($source, 1))
    }};
}

macro_rules! read_u16 {
    ($source:expr) => {{
        u16::from_be_bytes(read_bytes!($source, 2))
    }};
}

macro_rules! read_u32 {
    ($source:expr) => {{
        u32::from_be_bytes(read_bytes!($source, 4))
    }};
}

macro_rules! read_i32 {
    ($source:expr) => {{
        i32::from_be_bytes(read_bytes!($source, 4))
    }};
}

impl Op {
    pub fn parse(source: &mut impl Read) -> Result<Op, OpParseError> {
        let mut opcode = [0_u8; 1];
        source.read_exact(&mut opcode).unwrap();

        Ok(match opcode[0] {
            0x32 => Op::AALoad,
            0x53 => Op::AAStore,
            0x01 => Op::AConstNull,
            0x19 => Op::ALoad(read_u8!(source)),
            0x2a => Op::ALoad(0),
            0x2b => Op::ALoad(1),
            0x2c => Op::ALoad(2),
            0x2d => Op::ALoad(3),
            0xBD => Op::ANewArray(read_u16!(source)),
            0xB0 => Op::AReturn,
            0xBE => Op::ArrayLength,
            0x3A => Op::AStore(read_u8!(source)),
            0x4B => Op::AStore(0),
            0x4C => Op::AStore(1),
            0x4D => Op::AStore(2),
            0x4E => Op::AStore(3),
            0xBF => Op::AThrow,
            0x33 => Op::BALoad,
            0x54 => Op::BAStore,
            0x10 => Op::BIPush(read_i8!(source)),
            0x34 => Op::CALoad,
            0x55 => Op::CAStore,
            0xC0 => Op::CheckCast(read_u16!(source)),
            0x90 => Op::D2F,
            0x8E => Op::D2I,
            0x8F => Op::D2L,
            0x63 => Op::DAdd,
            0x31 => Op::DALoad,
            0x82 => Op::DAStore,
            0x97 => Op::DCmpL,
            0x98 => Op::DCmpG,
            0x0E => Op::DConst0,
            0x0F => Op::DConst1,
            0x6F => Op::DDiv,
            0x18 => Op::DLoad(read_u8!(source)),
            0x26 => Op::DLoad(0),
            0x27 => Op::DLoad(1),
            0x28 => Op::DLoad(2),
            0x29 => Op::DLoad(3),
            0x6B => Op::DMul,
            0x77 => Op::DNeg,
            0x73 => Op::DRem,
            0xAF => Op::DReturn,
            0x39 => Op::DStore(read_u8!(source)),
            0x47 => Op::DStore(0),
            0x48 => Op::DStore(1),
            0x49 => Op::DStore(2),
            0x4a => Op::DStore(3),
            0x67 => Op::DSub,
            0x59 => Op::Dup,
            0x5A => Op::DupX1,
            0x5B => Op::DupX2,
            0x5C => Op::Dup2,
            0x5D => Op::Dup2X1,
            0x5E => Op::Dup2X2,
            0x8D => Op::F2D,
            0x8B => Op::F2I,
            0x8C => Op::F2L,
            0x62 => Op::FAdd,
            0x30 => Op::FALoad,
            0x51 => Op::FAStore,
            0x95 => Op::FCmpL,
            0x96 => Op::FCmpG,
            0x0B => Op::FConst0,
            0x0C => Op::FConst1,
            0x0D => Op::FConst2,
            0x6E => Op::FDiv,
            0x17 => Op::FLoad(read_u8!(source)),
            0x22 => Op::FLoad(0),
            0x23 => Op::FLoad(1),
            0x24 => Op::FLoad(2),
            0x25 => Op::FLoad(3),
            0x6A => Op::FMul,
            0x76 => Op::FNeg,
            0x72 => Op::FRem,
            0xAE => Op::FReturn,
            0x38 => Op::FStore(read_u8!(source)),
            0x43 => Op::FStore(0),
            0x44 => Op::FStore(1),
            0x45 => Op::FStore(2),
            0x46 => Op::FStore(3),
            0x66 => Op::FSub,
            0xB4 => Op::GetField(read_u16!(source)),
            0xB2 => Op::GetStatic(read_u16!(source)),
            0xA7 => Op::Goto(read_u16!(source)),
            0xC8 => Op::GotoW(read_u32!(source)),
            0x91 => Op::I2B,
            0x92 => Op::I2C,
            0x87 => Op::I2D,
            0x86 => Op::I2F,
            0x85 => Op::I2L,
            0x93 => Op::I2S,
            0x60 => Op::IAdd,
            0x2E => Op::IALoad,
            0x7E => Op::IAnd,
            0x4F => Op::IAStore,
            0x02 => Op::IConstM1,
            0x03 => Op::IConst0,
            0x04 => Op::IConst1,
            0x05 => Op::IConst2,
            0x06 => Op::IConst3,
            0x07 => Op::IConst4,
            0x08 => Op::IConst5,
            0x6C => Op::IDiv,
            0xA5 => Op::IfACmpEq(read_u16!(source)),
            0xA6 => Op::IfACmpNe(read_u16!(source)),
            0x9F => Op::IfICmpEq(read_u16!(source)),
            0xA0 => Op::IfICmpNe(read_u16!(source)),
            0xA1 => Op::IfICmpLt(read_u16!(source)),
            0xA2 => Op::IfICmpGe(read_u16!(source)),
            0xA3 => Op::IfICmpGt(read_u16!(source)),
            0xA4 => Op::IfICmpLe(read_u16!(source)),
            0x99 => Op::IfEq(read_u16!(source)),
            0x9A => Op::IfNe(read_u16!(source)),
            0x9B => Op::IfLt(read_u16!(source)),
            0x9C => Op::IfGe(read_u16!(source)),
            0x9D => Op::IfGt(read_u16!(source)),
            0x9E => Op::IfLe(read_u16!(source)),
            0xC7 => Op::IfNonNull(read_u16!(source)),
            0xC6 => Op::IfNull(read_u16!(source)),
            0x84 => Op::IInc(read_u8!(source), read_i8!(source)),
            0x15 => Op::ILoad(read_u8!(source)),
            0x1A => Op::ILoad(0),
            0x1B => Op::ILoad(1),
            0x1C => Op::ILoad(2),
            0x1D => Op::ILoad(3),
            0x68 => Op::IMul,
            0x74 => Op::INeg,
            0xC1 => Op::InstanceOf(read_u16!(source)),
            0xBA => Op::InvokeDynamic(read_u16!(source)),
            0xB9 => Op::InvokeInterface(read_u16!(source), read_u8!(source)),
            0xB7 => Op::InvokeSpecial(read_u16!(source)),
            0xB8 => Op::InvokeStatic(read_u16!(source)),
            0xB6 => Op::InvokeVirtual(read_u16!(source)),
            0x80 => Op::IOr,
            0x70 => Op::IRem,
            0xAC => Op::IReturn,
            0x78 => Op::IShl,
            0x7A => Op::IShr,
            0x36 => Op::IStore(read_u8!(source)),
            0x3B => Op::IStore(0),
            0x3C => Op::IStore(1),
            0x3D => Op::IStore(2),
            0x3E => Op::IStore(3),
            0x64 => Op::ISub,
            0x7C => Op::IUShr,
            0x82 => Op::IXor,
            0xA8 => Op::Jsr(read_u16!(source)),
            0xC9 => Op::JsrW(read_u32!(source)),
            0x8A => Op::L2D,
            0x89 => Op::L2F,
            0x88 => Op::L2I,
            0x61 => Op::LAdd,
            0x2F => Op::LALoad,
            0x7F => Op::LAnd,
            0x50 => Op::LAStore,
            0x94 => Op::LCmp,
            0x09 => Op::LConst0,
            0x0A => Op::LConst1,
            0x12 => Op::LDC(read_u8!(source)),
            0x13 => Op::LDCW(read_u16!(source)),
            0x14 => Op::LDC2W(read_u16!(source)),
            0x6D => Op::LDiv,
            0x16 => Op::LLoad(read_u8!(source)),
            0x1E => Op::LLoad(0),
            0x1F => Op::LLoad(1),
            0x20 => Op::LLoad(2),
            0x21 => Op::LLoad(3),
            0x69 => Op::LMul,
            0x75 => Op::LNeg,
            0xAB => {
                todo!("padding");
                let default = read_u32!(source);
                let npairs_count = read_u32!(source);
                let mut npairs = Vec::with_capacity(npairs_count as usize);
                for _ in 0..npairs_count {
                    npairs.push((read_i32!(source), read_i32!(source)));
                }
                Op::LookupSwitch { default, npairs }
            }
            0x81 => Op::LOr,
            0x71 => Op::LRem,
            0xAD => Op::LReturn,
            0x79 => Op::LShl,
            0x7B => Op::LShr,
            0x37 => Op::LStore(read_u8!(source)),
            0x3F => Op::LStore(0),
            0x40 => Op::LStore(1),
            0x41 => Op::LStore(2),
            0x42 => Op::LStore(3),
            0x65 => Op::LSub,
            0x7D => Op::LUShr,
            0x83 => Op::LXor,
            0xC2 => Op::MonitorEnter,
            0xC3 => Op::MonitorExit,
            0xC5 => Op::MultiANewArray(read_u16!(source), read_u8!(source)),
            0xBB => Op::New(read_u16!(source)),
            0xBC => Op::NewArray(match read_u8!(source) {
                4 => AType::TBoolean,
                5 => AType::TChar,
                6 => AType::TFloat,
                7 => AType::TDouble,
                8 => AType::TByte,
                9 => AType::TShort,
                10 => AType::TInt,
                11 => AType::TLong,
                _ => panic!("invalid atype"),
            }),
            0x00 => Op::Nop,
            0x57 => Op::Pop,
            0x58 => Op::Pop2,
            0xB5 => Op::PutField(read_u16!(source)),
            0xB3 => Op::PutStatic(read_u16!(source)),
            0xA9 => Op::Ret(read_u8!(source)),
            0xB1 => Op::Return,
            0x35 => Op::SALoad,
            0x56 => Op::SAStore,
            0x11 => Op::SIPush(read_u16!(source)),
            0x5F => Op::Swap,
            0xAA => {
                todo!("padding");
                let default = read_i32!(source);
                let low = read_i32!(source);
                let high = read_i32!(source);
                let mut offsets = Vec::with_capacity((high - low + 1) as usize);
                for _ in 0..high - low + 1 {
                    offsets.push(read_i32!(source));
                }
                Op::TableSwitch {
                    default,
                    low,
                    high,
                    offsets,
                }
            }
            0xC4 => Op::Wide,
            0xCA => Op::Breakpoint,
            _ => return Err(OpParseError::InvalidByteCode),
        })
    }
}
